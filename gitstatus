#!/bin/bash
# -*- coding: UTF-8 -*-
# gitstatus -- produce the current git repo status on STDOUT
#
# based on code from: Alan K. Stebbens <aks@stebbens.org> [http://github.com/aks]

# helper functions
count_lines() { echo "$1" | grep -E -c -e "^$2" ; }
all_lines() { echo "$1" | grep -E -c -v "^$" ; }

# is git even installed?
which git > /dev/null 2>&1 || exit

# are we even in a working tree?
inrepo=$(git rev-parse --is-inside-work-tree 2>&1)
[[ $? -ne 0 ]] && exit 0
case "$inrepo" in
fatal*)	exit 0 ;;
false)	exit 0 ;;
esac

COLORS="true"
PRINT_WORK_DIR="false"
VERBOSE="false"

while [[ $# -gt 0 ]]; do
	key="$1"
	val="${key#*=}"

	case $key in
	--colors=*)
		COLORS="$val"
	;;
	--nocolors)
		COLORS="false"
	;;
	--pwd)
		PRINT_WORK_DIR="true"
	;;
	--verbose)
		VERBOSE="true"
	;;
	--)
		shift
		break
	;;
	--*)
		echo "unknown flag $1" >&2
		exit 1
	;;
	*)
		break
	;;
	esac
	shift
done

remote="$(git remote)"
case $remote in
""|local) ;;
*)
	url="$(git remote get-url $(git remote))"
	case "$url" in
	http:*)
		scheme="http"
		host=${url#http://}
		user=${host%%@*}
		[[ $user = $host ]] && user=""
		host=${host##*@}
		path=${host#*/}
		host=${host%%/*}
		port=80
	;;
	https:*)
		scheme="https"
		host=${url#https://}
		user=${host%%@*}
		[[ $user = $host ]] && user=""
		host=${host##*@}
		path=${host#*/}
		host=${host%%/*}
		port=443
	;;
	*)
		scheme="ssh"
		user=${url%%@*}
		host=${url##*@}
		path=${host##*:}
		path=${path%.git}
		host=${host%%:*}
		port=22
	;;
	esac

	[[ $VERBOSE = "true" ]] && echo "url:$url" "scheme:$scheme" "user:$user" "host:$host" "port:$port" "path:$path"

	case $host in
	github.com) ;;
	nix.eseke.net) ;;
	*)
		# avoid spurious fetch attempts
		host=
	;;
	esac

	if [[ -n $host ]]; then
		head_file="$(git rev-parse --git-dir)/FETCH_HEAD"

		now="$(date +%s)"
		modt=$now
		inettest="true"
		case "$OSTYPE" in
		linux*)
			modt=$(stat -c %Y -t $head_file 2> /dev/null)
			inettest="/usr/bin/nc -w 1 $host $port"
		;;
		darwin*)
			modt=$(stat -f %m $head_file 2> /dev/null)
			inettest="/usr/bin/nc -G 1 -w 1 $host $port"
		;;
		esac

		if [[ -n $modt ]]; then
			#advance modification time by 24-hours
			modt="$(expr $modt + 86400)"
			if [[ $now -gt $modt ]]; then
				if $inettest > /dev/null 2>&1; then
					echo "git fetch…"
					git fetch > /dev/null 2>&1

				else
					echo "remote down"
					touch $head_file
				fi
			fi
		fi
	fi
;;
esac

gitstatus=$(git status --porcelain --branch --untracked-files=all 2>&1)
# if the diff is fatal, exit now
case "$gitstatus" in
fatal*)	exit 0 ;;
esac

branchinfo=$(echo "$gitstatus" | grep -F "## ")
branchinfo=${branchinfo##\#\# }

remote=${branchinfo##*...}
remote=${remote%% *}
remote=${remote#origin/}

branch=${branchinfo%%...*}
case $branch in
*"No commits yet on "*)
	branch=${branch##*No commits yet on }
	remote="local"
;;
*"Initial commit on "*)
	branch=${branch##*Initial commit on }
	remote="local"
;;
esac

num_ahead=$(echo "$branchinfo" | grep -o "ahead [0-9][0-9]*")
num_ahead=${num_ahead#ahead }

num_behind=$(echo "$branchinfo" | grep -o "behind [0-9][0-9]*")
num_behind=${num_behind#behind }

GOOD_CHANGE_PATTERN="[ACDMRT]"

num_untracked=$(count_lines "$gitstatus" "\?\?")
num_staged=$(count_lines "$gitstatus" "${GOOD_CHANGE_PATTERN} ")
num_changed=$(count_lines "$gitstatus", " ${GOOD_CHANGE_PATTERN}")
num_moving=$(count_lines "$gitstatus", "RM")

num_alert=$(( $(count_lines "$gitstatus" "[UXB]") + $(count_lines "$gitstatus" "[^ #?UXB][^ ]") ))

num_stashed=0
if [[ -z "$GIT_PROMPT_IGNORE_STASH" ]]; then
	num_stashed=$(git stash list | grep -E -c -v "^$")
fi

# get our prompt colors if they exist
[[ $COLORS = "true" && -r ~/.promptcolors ]] && . ~/.promptcolors

# if remote is same as branch, then it is redundant info,
# so don’t show it.
if [[ $remote = $branch ]]; then
	remote=
fi

case $remote in
"")	;;
local)	branch="${branch}:${SHARP}$remote" ;;
*)	branch="${branch}:${BLUNT}$remote" ;;
esac

if [[ -n $user && $scheme != "ssh" ]]; then
	branch="${SHARP}‽${NORMAL}@${branch}"
fi

tracking=
[[ -n $num_ahead ]]  && tracking="${tracking}${BLUNT}↑${num_ahead}"
[[ -n $num_behind ]] && tracking="${tracking}${SHARP}↓${num_behind}"

state="${GOOD}✓"
if [[ $(( num_staged + num_alert + num_changed + num_untracked + num_stashed )) != 0 ]] ; then
	state=
	[[ $num_alert -gt 0 ]]     && state="${state}${PIERCE}!${num_alert}"
	[[ $num_stashed -gt 0 ]]   && state="${state}${SHARP}⚑${num_stashed}"
	[[ $num_moving -gt 0 ]]    && state="${state}${SHARP}↻${num_moving}"
	[[ $num_staged -gt 0 ]]    && state="${state}${SHARP}●${num_staged}"
	[[ $num_changed -gt 0 ]]   && state="${state}${FLUFFY}∆${num_changed}"
	[[ $num_untracked -gt 0 ]] && state="${state}${SHARP}…${num_untracked}"
fi

[[ $PRINT_WORK_DIR = "true" ]] && workdir="${BLUNT}$(basename "${PWD}")${NORMAL}:"

printf "${NORMAL}${workdir}[${branch}${tracking}${NORMAL}|${state}${NORMAL}]\n"
